<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .menu {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            text-align: center;
            max-width: 400px;
        }

        .menu h1 {
            color: #ffd700;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        .menu button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(245, 87, 108, 0.5);
        }

        #gameContainer {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #arena {
            position: relative;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #4a90e2 0%, #8b4513 50%, #e74c3c 100%);
            overflow: hidden;
        }

        .bridge {
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-50%);
        }

        .tower {
            position: absolute;
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #8b4513, #a0522d);
            border-radius: 10px 10px 0 0;
            border: 3px solid #654321;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .tower.player {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            border-color: #0D47A1;
        }

        .tower::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 20px solid #654321;
        }

        .tower.player::before {
            border-bottom-color: #0D47A1;
        }

        .tower-hp {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
        }

        .unit {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 12px;
            transition: all 0.1s;
            cursor: pointer;
            pointer-events: none;
        }

        .unit.player {
            background: radial-gradient(circle, #2196F3, #1565C0);
            border: 2px solid #0D47A1;
        }

        .unit.enemy {
            background: radial-gradient(circle, #f44336, #c62828);
            border: 2px solid #b71c1c;
        }

        .projectile {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 10px #ffd700;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8), transparent);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        #cardDeck {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .card {
            width: 80px;
            height: 100px;
            background: linear-gradient(135deg, #6a1b9a, #9c27b0);
            border-radius: 10px;
            border: 3px solid #4a148c;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 30px rgba(156, 39, 176, 0.6);
        }

        .card.selected {
            transform: translateY(-20px);
            border-color: #ffd700;
            box-shadow: 0 0 20px #ffd700;
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-cost {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ff4081;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .card-name {
            font-size: 11px;
            margin-top: 10px;
        }

        .card-icon {
            font-size: 28px;
        }

        #elixir {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(156, 39, 176, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        .elixir-bar {
            width: 200px;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }

        .elixir-fill {
            height: 100%;
            background: linear-gradient(90deg, #e91e63, #ff4081);
            border-radius: 5px;
            transition: width 0.3s;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            z-index: 200;
            display: none;
        }

        .game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .game-over.victory h2 {
            color: #4CAF50;
        }

        .game-over.defeat h2 {
            color: #f44336;
        }

        .game-over button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
        }

        .damage-text {
            position: absolute;
            color: #ff4444;
            font-weight: bold;
            font-size: 20px;
            animation: damageFloat 1s forwards;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        @keyframes spellEffect {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        #crownCount {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .crown-display {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .crown {
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div class="menu" id="menu">
        <h1>‚öîÔ∏è CLASH ROYALE</h1>
        <button onclick="startGame('easy')">Easy Mode</button>
        <button onclick="startGame('medium')">Medium Mode</button>
        <button onclick="startGame('hard')">Hard Mode</button>
    </div>

    <div id="gameContainer">
        <div id="arena">
            <div class="bridge"></div>
        </div>
        <div id="hud">
            <div id="crownCount">
                <div class="crown-display">
                    <span class="crown">üëë</span>
                    <span id="playerCrowns">0</span>
                </div>
                <div>YOU</div>
            </div>
            <div id="timer">3:00</div>
            <div id="crownCount">
                <div>ENEMY</div>
                <div class="crown-display">
                    <span id="enemyCrowns">0</span>
                    <span class="crown">üëë</span>
                </div>
            </div>
        </div>
        <div id="elixir">
            Elixir: <span id="elixirCount">0</span>/10
            <div class="elixir-bar">
                <div class="elixir-fill" id="elixirFill"></div>
            </div>
        </div>
        <div id="cardDeck"></div>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="gameOverText">VICTORY!</h2>
        <p id="gameOverStats"></p>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <script>
        const CARDS = [
            {name: 'Knight', cost: 3, hp: 600, damage: 80, speed: 2, range: 1, icon: 'üõ°Ô∏è', type: 'troop'},
            {name: 'Archer', cost: 3, hp: 200, damage: 50, speed: 2, range: 150, icon: 'üèπ', type: 'troop'},
            {name: 'Giant', cost: 5, hp: 1200, damage: 100, speed: 1, range: 1, icon: 'üóø', type: 'troop'},
            {name: 'Goblin', cost: 2, hp: 100, damage: 40, speed: 3, range: 1, icon: 'üë∫', type: 'troop'},
            {name: 'Wizard', cost: 5, hp: 300, damage: 120, speed: 2, range: 180, icon: 'üßô', type: 'troop'},
            {name: 'Mini PEKKA', cost: 4, hp: 600, damage: 150, speed: 2, range: 1, icon: 'ü§ñ', type: 'troop'},
            {name: 'Musketeer', cost: 4, hp: 350, damage: 80, speed: 2, range: 200, icon: 'üî´', type: 'troop'},
            {name: 'Hog Rider', cost: 4, hp: 800, damage: 120, speed: 3.5, range: 1, icon: 'üêó', type: 'troop'},
            {name: 'Fireball', cost: 4, damage: 400, radius: 100, icon: 'üî•', type: 'spell'},
            {name: 'Arrows', cost: 3, damage: 200, radius: 120, icon: 'üèπ', type: 'spell'},
            {name: 'Lightning', cost: 6, damage: 600, radius: 80, icon: '‚ö°', type: 'spell'},
            {name: 'Zap', cost: 2, damage: 150, radius: 80, icon: '‚ö°', type: 'spell'},
            {name: 'Freeze', cost: 4, duration: 90, radius: 100, icon: '‚ùÑÔ∏è', type: 'spell'},
            {name: 'Rage', cost: 2, duration: 120, radius: 120, icon: 'üò°', type: 'spell'},
            {name: 'Heal', cost: 3, healing: 300, duration: 60, radius: 100, icon: 'üíö', type: 'spell'},
            {name: 'Poison', cost: 4, damage: 25, duration: 180, radius: 110, icon: '‚ò†Ô∏è', type: 'spell'},
            {name: 'Baby Dragon', cost: 4, hp: 800, damage: 100, speed: 2, range: 100, icon: 'üê≤', type: 'troop'},
            {name: 'Valkyrie', cost: 4, hp: 900, damage: 110, speed: 2, range: 1, icon: '‚öîÔ∏è', type: 'troop'},
            {name: 'Prince', cost: 5, hp: 1200, damage: 200, speed: 3, range: 1, icon: 'ü§¥', type: 'troop'},
            {name: 'Witch', cost: 5, hp: 500, damage: 60, speed: 2, range: 150, icon: 'üßô‚Äç‚ôÄÔ∏è', type: 'troop'},
            {name: 'Bomber', cost: 3, hp: 250, damage: 100, speed: 2, range: 120, icon: 'üí£', type: 'troop'},
            {name: 'Skeleton Army', cost: 3, hp: 60, damage: 60, speed: 3, range: 1, icon: 'üíÄ', type: 'swarm', count: 8},
            {name: 'Minion Horde', cost: 5, hp: 150, damage: 50, speed: 3, range: 80, icon: 'ü¶á', type: 'swarm', count: 6},
            {name: 'Goblin Gang', cost: 3, hp: 120, damage: 50, speed: 3, range: 1, icon: 'üëπ', type: 'swarm', count: 5},
            {name: 'Balloon', cost: 5, hp: 1000, damage: 500, speed: 2, range: 1, icon: 'üéà', type: 'troop'},
            {name: 'P.E.K.K.A', cost: 7, hp: 2400, damage: 400, speed: 1.5, range: 1, icon: 'ü§ñ', type: 'troop'},
            {name: 'Golem', cost: 8, hp: 3000, damage: 120, speed: 1, range: 1, icon: 'üóø', type: 'troop'},
            {name: 'Miner', cost: 3, hp: 500, damage: 80, speed: 2, range: 1, icon: '‚õèÔ∏è', type: 'troop'},
            {name: 'Inferno Dragon', cost: 4, hp: 800, damage: 50, speed: 2, range: 100, icon: 'üêâ', type: 'troop'},
            {name: 'Sparky', cost: 6, hp: 1000, damage: 800, speed: 1, range: 120, icon: '‚ö°', type: 'troop'},
            {name: 'Rocket', cost: 6, damage: 800, radius: 80, icon: 'üöÄ', type: 'spell'},
            {name: 'Mirror', cost: 1, icon: 'ü™û', type: 'special'},
            {name: 'Clone', cost: 3, radius: 100, icon: 'üë•', type: 'spell'}
        ];

        let gameState = {
            difficulty: 'medium',
            elixir: 5,
            maxElixir: 10,
            playerCrowns: 0,
            enemyCrowns: 0,
            timeLeft: 180,
            units: [],
            projectiles: [],
            towers: [],
            selectedCard: null,
            deck: [],
            gameRunning: false
        };

        const difficultySettings = {
            easy: {aiDelay: 4000, aiElixirMult: 0.8},
            medium: {aiDelay: 3000, aiElixirMult: 1},
            hard: {aiDelay: 2000, aiElixirMult: 1.2}
        };

        let lastPlayedCard = null;

        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            initGame();
        }

        function initGame() {
            gameState.gameRunning = true;
            gameState.elixir = 5;
            gameState.units = [];
            gameState.projectiles = [];
            gameState.towers = [];
            gameState.playerCrowns = 0;
            gameState.enemyCrowns = 0;
            gameState.timeLeft = 180;

            createTowers();
            createDeck();
            startElixirGeneration();
            startTimer();
            startAI();
            gameLoop();
        }

        function createTowers() {
            const arena = document.getElementById('arena');
            const arenaWidth = arena.offsetWidth;
            const arenaHeight = arena.offsetHeight;

            // Player towers (bottom)
            createTower(arenaWidth / 2 - 30, arenaHeight - 100, 2500, true, true); // King
            createTower(100, arenaHeight - 200, 1500, true, false); // Left Princess
            createTower(arenaWidth - 160, arenaHeight - 200, 1500, true, false); // Right Princess

            // Enemy towers (top)
            createTower(arenaWidth / 2 - 30, 20, 2500, false, true); // King
            createTower(100, 120, 1500, false, false); // Left Princess
            createTower(arenaWidth - 160, 120, 1500, false, false); // Right Princess
        }

        function createTower(x, y, hp, isPlayer, isKing) {
            const tower = {
                x, y, hp, maxHp: hp, isPlayer, isKing,
                attackCooldown: 0,
                damage: 50,
                range: 200,
                element: document.createElement('div')
            };
            tower.element.className = 'tower' + (isPlayer ? ' player' : '');
            tower.element.style.left = x + 'px';
            tower.element.style.top = y + 'px';
            tower.element.innerHTML = `<div class="tower-hp">${hp}</div>`;
            document.getElementById('arena').appendChild(tower.element);
            gameState.towers.push(tower);
        }

        function createDeck() {
            const deck = document.getElementById('cardDeck');
            deck.innerHTML = '';
            gameState.deck = [];
            
            // Create deck with unique cards
            const availableCards = [...CARDS];
            for (let i = 0; i < 4; i++) {
                const randomIndex = Math.floor(Math.random() * availableCards.length);
                const card = availableCards.splice(randomIndex, 1)[0];
                gameState.deck.push({...card});
                const cardEl = document.createElement('div');
                cardEl.className = 'card';
                cardEl.innerHTML = `
                    <div class="card-cost">${card.cost}</div>
                    <div class="card-icon">${card.icon}</div>
                    <div class="card-name">${card.name}</div>
                `;
                cardEl.onclick = () => selectCard(i);
                deck.appendChild(cardEl);
            }
        }

        function selectCard(index) {
            const card = gameState.deck[index];
            if (gameState.elixir >= card.cost) {
                document.querySelectorAll('.card').forEach((el, i) => {
                    el.classList.toggle('selected', i === index);
                });
                gameState.selectedCard = index;
                document.getElementById('arena').style.cursor = 'crosshair';
            }
        }

        document.getElementById('arena').addEventListener('click', (e) => {
            if (gameState.selectedCard !== null) {
                const card = gameState.deck[gameState.selectedCard];
                const arena = document.getElementById('arena');
                const rect = arena.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Only allow placement in player's half (bottom half) for troops
                const canPlace = card.type === 'spell' || card.type === 'special' || y > arena.offsetHeight / 2;
                
                if (canPlace) {
                    if (gameState.elixir >= card.cost) {
                        if (card.type === 'troop') {
                            spawnUnit(x, y, card, true);
                        } else if (card.type === 'swarm') {
                            spawnSwarm(x, y, card, true);
                        } else if (card.type === 'spell') {
                            castSpell(x, y, card, true);
                        } else if (card.type === 'special') {
                            useSpecial(x, y, card, true);
                        }
                        
                        gameState.elixir -= card.cost;
                        updateElixir();
                        
                        // Save for mirror
                        if (card.name !== 'Mirror') {
                            lastPlayedCard = {...card};
                        }
                        
                        // Replace card
                        const newCard = CARDS[Math.floor(Math.random() * CARDS.length)];
                        gameState.deck[gameState.selectedCard] = {...newCard};
                        createDeck();
                        gameState.selectedCard = null;
                        document.getElementById('arena').style.cursor = 'default';
                    }
                }
            }
        });

        function spawnUnit(x, y, card, isPlayer) {
            // Check for collision and find free spot
            const finalPos = findFreeSpot(x, y, 40);
            
            const unit = {
                x: finalPos.x, 
                y: finalPos.y,
                hp: card.hp,
                maxHp: card.hp,
                damage: card.damage,
                speed: card.speed,
                range: card.range,
                isPlayer,
                name: card.name,
                icon: card.icon,
                attackCooldown: 0,
                frozen: 0,
                rageBoost: 0,
                poisoned: 0,
                element: document.createElement('div')
            };
            
            unit.element.className = 'unit' + (isPlayer ? ' player' : ' enemy');
            unit.element.textContent = card.icon;
            unit.element.style.left = finalPos.x + 'px';
            unit.element.style.top = finalPos.y + 'px';
            document.getElementById('arena').appendChild(unit.element);
            gameState.units.push(unit);
        }

        function findFreeSpot(x, y, radius) {
            const maxAttempts = 20;
            for (let i = 0; i < maxAttempts; i++) {
                const angle = (Math.PI * 2 * i) / maxAttempts;
                const testX = x + Math.cos(angle) * (radius * i / 4);
                const testY = y + Math.sin(angle) * (radius * i / 4);
                
                let collides = false;
                for (let unit of gameState.units) {
                    const dist = Math.sqrt((unit.x - testX) ** 2 + (unit.y - testY) ** 2);
                    if (dist < 35) {
                        collides = true;
                        break;
                    }
                }
                
                if (!collides) {
                    return {x: testX, y: testY};
                }
            }
            return {x, y};
        }

        function spawnSwarm(x, y, card, isPlayer) {
            const count = card.count || 5;
            const radius = 40;
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const offsetX = Math.cos(angle) * radius;
                const offsetY = Math.sin(angle) * radius;
                spawnUnit(x + offsetX, y + offsetY, card, isPlayer);
            }
        }

        function castSpell(x, y, card, isPlayer) {
            // Visual effect
            const effect = document.createElement('div');
            effect.style.position = 'absolute';
            effect.style.left = (x - card.radius) + 'px';
            effect.style.top = (y - card.radius) + 'px';
            effect.style.width = (card.radius * 2) + 'px';
            effect.style.height = (card.radius * 2) + 'px';
            effect.style.borderRadius = '50%';
            effect.style.pointerEvents = 'none';
            effect.style.zIndex = '50';
            
            if (card.name === 'Fireball') {
                effect.style.background = 'radial-gradient(circle, rgba(255,100,0,0.8), rgba(255,0,0,0.4))';
            } else if (card.name === 'Arrows') {
                effect.style.background = 'radial-gradient(circle, rgba(139,69,19,0.6), rgba(101,67,33,0.2))';
            } else if (card.name === 'Lightning') {
                effect.style.background = 'radial-gradient(circle, rgba(255,255,0,0.9), rgba(255,215,0,0.4))';
            } else if (card.name === 'Zap') {
                effect.style.background = 'radial-gradient(circle, rgba(100,200,255,0.8), rgba(0,150,255,0.3))';
            } else if (card.name === 'Freeze') {
                effect.style.background = 'radial-gradient(circle, rgba(0,200,255,0.6), rgba(200,230,255,0.3))';
            } else if (card.name === 'Rage') {
                effect.style.background = 'radial-gradient(circle, rgba(255,0,150,0.6), rgba(200,0,100,0.3))';
            } else if (card.name === 'Heal') {
                effect.style.background = 'radial-gradient(circle, rgba(0,255,100,0.6), rgba(100,255,150,0.3))';
            } else if (card.name === 'Poison') {
                effect.style.background = 'radial-gradient(circle, rgba(100,255,0,0.5), rgba(50,200,0,0.2))';
            } else if (card.name === 'Rocket') {
                effect.style.background = 'radial-gradient(circle, rgba(255,50,0,0.9), rgba(200,0,0,0.5))';
            } else if (card.name === 'Clone') {
                effect.style.background = 'radial-gradient(circle, rgba(200,0,255,0.6), rgba(150,0,200,0.3))';
            }
            
            effect.style.animation = 'spellEffect 0.5s ease-out';
            document.getElementById('arena').appendChild(effect);
            setTimeout(() => effect.remove(), 500);

            // Apply spell effects
            if (card.name === 'Freeze') {
                applyAreaEffect(x, y, card.radius, (target) => {
                    if (target.isPlayer !== isPlayer) {
                        target.frozen = card.duration;
                        target.element.style.filter = 'brightness(0.7) saturate(0.5)';
                    }
                });
            } else if (card.name === 'Rage') {
                applyAreaEffect(x, y, card.radius, (target) => {
                    if (target.isPlayer === isPlayer) {
                        target.rageBoost = card.duration;
                        target.element.style.filter = 'brightness(1.3) saturate(1.5)';
                    }
                });
            } else if (card.name === 'Heal') {
                applyAreaEffect(x, y, card.radius, (target) => {
                    if (target.isPlayer === isPlayer) {
                        target.hp = Math.min(target.maxHp, target.hp + card.healing);
                    }
                });
            } else if (card.name === 'Poison') {
                const poisonZone = {
                    x, y, radius: card.radius, duration: card.duration,
                    damage: card.damage, isPlayer, tickCounter: 0
                };
                gameState.poisonZones = gameState.poisonZones || [];
                gameState.poisonZones.push(poisonZone);
            } else {
                // Damage spells
                applyAreaEffect(x, y, card.radius, (target) => {
                    if (target.isPlayer !== isPlayer) {
                        dealDamage(target, card.damage, target.x || (target.x + 30), target.y || (target.y + 40));
                    }
                });
            }
        }

        function useSpecial(x, y, card, isPlayer) {
            if (card.name === 'Mirror' && lastPlayedCard) {
                const mirrorCard = {...lastPlayedCard};
                if (mirrorCard.type === 'troop') {
                    spawnUnit(x, y, mirrorCard, isPlayer);
                } else if (mirrorCard.type === 'swarm') {
                    spawnSwarm(x, y, mirrorCard, isPlayer);
                } else if (mirrorCard.type === 'spell') {
                    castSpell(x, y, mirrorCard, isPlayer);
                }
            } else if (card.name === 'Clone') {
                applyAreaEffect(x, y, card.radius, (target) => {
                    if (target.isPlayer === isPlayer && target.hp > 0) {
                        const cloneCard = {
                            name: target.name,
                            hp: target.hp,
                            damage: target.damage,
                            speed: target.speed,
                            range: target.range,
                            icon: target.icon
                        };
                        spawnUnit(target.x + 20, target.y + 20, cloneCard, isPlayer);
                    }
                });
            }
        }

        function applyAreaEffect(x, y, radius, callback) {
            // Apply to units
            gameState.units.forEach(unit => {
                const dist = Math.sqrt((unit.x - x) ** 2 + (unit.y - y) ** 2);
                if (dist <= radius) {
                    callback(unit);
                }
            });

            // Apply to towers
            gameState.towers.forEach(tower => {
                const dist = Math.sqrt((tower.x + 30 - x) ** 2 + (tower.y + 40 - y) ** 2);
                if (dist <= radius) {
                    callback(tower);
                }
            });
        }

        function startElixirGeneration() {
            setInterval(() => {
                if (gameState.gameRunning && gameState.elixir < gameState.maxElixir) {
                    gameState.elixir = Math.min(gameState.maxElixir, gameState.elixir + 1);
                    updateElixir();
                }
            }, 2800);
        }

        function updateElixir() {
            document.getElementById('elixirCount').textContent = Math.floor(gameState.elixir);
            document.getElementById('elixirFill').style.width = (gameState.elixir / gameState.maxElixir * 100) + '%';
            
            document.querySelectorAll('.card').forEach((el, i) => {
                if (gameState.deck[i] && gameState.elixir < gameState.deck[i].cost) {
                    el.classList.add('disabled');
                } else {
                    el.classList.remove('disabled');
                }
            });
        }

        function startTimer() {
            setInterval(() => {
                if (gameState.gameRunning) {
                    gameState.timeLeft--;
                    const mins = Math.floor(gameState.timeLeft / 60);
                    const secs = gameState.timeLeft % 60;
                    document.getElementById('timer').textContent = 
                        `${mins}:${secs.toString().padStart(2, '0')}`;
                    
                    if (gameState.timeLeft <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }

        function startAI() {
            const settings = difficultySettings[gameState.difficulty];
            let aiElixir = 5;
            
            setInterval(() => {
                if (gameState.gameRunning) {
                    aiElixir = Math.min(10, aiElixir + settings.aiElixirMult);
                    
                    const card = CARDS[Math.floor(Math.random() * CARDS.length)];
                    if (aiElixir >= card.cost) {
                        const arena = document.getElementById('arena');
                        
                        if (card.type === 'troop' || card.type === 'swarm') {
                            // Place troops in AI's territory (top half)
                            const x = Math.random() * (arena.offsetWidth - 100) + 50;
                            const y = Math.random() * (arena.offsetHeight / 2 - 100) + 50;
                            
                            if (card.type === 'troop') {
                                spawnUnit(x, y, card, false);
                            } else {
                                spawnSwarm(x, y, card, false);
                            }
                            aiElixir -= card.cost;
                        } else if (card.type === 'spell') {
                            const spellTarget = getAISpellTarget(card, arena);
                            if (spellTarget) {
                                castSpell(spellTarget.x, spellTarget.y, card, false);
                                aiElixir -= card.cost;
                            }
                        } else if (card.type === 'special') {
                            // Don't use special cards for AI (too complex)
                        }
                    }
                }
            }, settings.aiDelay);
        }

        function getAISpellTarget(card, arena) {
            const isDefensiveSpell = ['Freeze', 'Rage', 'Heal'].includes(card.name);
            
            if (isDefensiveSpell) {
                // Target AI's own units that are under attack
                const aiUnits = gameState.units.filter(u => !u.isPlayer && u.hp > 0);
                
                if (card.name === 'Freeze') {
                    // Find cluster of player units threatening AI
                    const playerUnits = gameState.units.filter(u => u.isPlayer && u.hp > 0 && u.y < arena.offsetHeight / 2);
                    if (playerUnits.length > 0) {
                        // Find center of largest cluster
                        const cluster = findLargestCluster(playerUnits, card.radius);
                        if (cluster.count >= 2) {
                            return {x: cluster.x, y: cluster.y};
                        }
                    }
                } else if (card.name === 'Rage' || card.name === 'Heal') {
                    // Target AI units that are pushing
                    const pushingUnits = aiUnits.filter(u => u.y > arena.offsetHeight / 3);
                    if (pushingUnits.length > 0) {
                        const cluster = findLargestCluster(pushingUnits, card.radius);
                        if (cluster.count >= 2) {
                            return {x: cluster.x, y: cluster.y};
                        }
                    }
                }
            } else {
                // Offensive spells - target player units or towers
                const playerUnits = gameState.units.filter(u => u.isPlayer && u.hp > 0);
                
                if (card.name === 'Rocket' || card.name === 'Lightning') {
                    // High-cost spells: prioritize towers or high-value targets
                    const playerTowers = gameState.towers.filter(t => t.isPlayer && t.hp > 0 && t.hp < t.maxHp * 0.4);
                    if (playerTowers.length > 0) {
                        const tower = playerTowers[0];
                        return {x: tower.x + 30, y: tower.y + 40};
                    }
                    
                    // Or target expensive units
                    const expensiveUnits = playerUnits.filter(u => 
                        ['Giant', 'P.E.K.K.A', 'Golem', 'Sparky', 'Balloon'].includes(u.name)
                    );
                    if (expensiveUnits.length > 0) {
                        return {x: expensiveUnits[0].x, y: expensiveUnits[0].y};
                    }
                } else {
                    // Area damage spells - target clusters
                    if (playerUnits.length > 0) {
                        const cluster = findLargestCluster(playerUnits, card.radius);
                        if (cluster.count >= 2) {
                            return {x: cluster.x, y: cluster.y};
                        }
                        // If no cluster, target any unit
                        return {x: playerUnits[0].x, y: playerUnits[0].y};
                    }
                }
            }
            
            return null; // Don't cast if no good target
        }

        function findLargestCluster(units, radius) {
            let bestCluster = {x: 0, y: 0, count: 0};
            
            for (let unit of units) {
                let count = 0;
                let sumX = 0;
                let sumY = 0;
                
                for (let other of units) {
                    const dist = Math.sqrt((unit.x - other.x) ** 2 + (unit.y - other.y) ** 2);
                    if (dist <= radius) {
                        count++;
                        sumX += other.x;
                        sumY += other.y;
                    }
                }
                
                if (count > bestCluster.count) {
                    bestCluster = {
                        x: sumX / count,
                        y: sumY / count,
                        count: count
                    };
                }
            }
            
            return bestCluster;
        }

        function gameLoop() {
            if (!gameState.gameRunning) return;

            // Update poison zones
            if (gameState.poisonZones) {
                gameState.poisonZones.forEach(zone => {
                    zone.tickCounter++;
                    if (zone.tickCounter % 30 === 0) { // Damage every 30 frames
                        applyAreaEffect(zone.x, zone.y, zone.radius, (target) => {
                            if (target.isPlayer !== zone.isPlayer) {
                                dealDamage(target, zone.damage, target.x || (target.x + 30), target.y || (target.y + 40));
                            }
                        });
                    }
                    zone.duration--;
                });
                gameState.poisonZones = gameState.poisonZones.filter(z => z.duration > 0);
            }

            // Update towers - make them attack
            gameState.towers.forEach(tower => {
                if (tower.hp <= 0) return;

                tower.attackCooldown = Math.max(0, tower.attackCooldown - 1);

                if (tower.attackCooldown === 0) {
                    // Find nearest enemy unit
                    let nearestEnemy = null;
                    let minDist = tower.range;

                    gameState.units.forEach(unit => {
                        if (unit.isPlayer !== tower.isPlayer && unit.hp > 0) {
                            const dx = unit.x - (tower.x + 30);
                            const dy = unit.y - (tower.y + 40);
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < minDist) {
                                minDist = dist;
                                nearestEnemy = unit;
                            }
                        }
                    });

                    // Attack if enemy in range
                    if (nearestEnemy) {
                        const proj = {
                            x: tower.x + 30,
                            y: tower.y + 40,
                            targetX: nearestEnemy.x,
                            targetY: nearestEnemy.y,
                            damage: tower.damage,
                            target: nearestEnemy,
                            element: document.createElement('div')
                        };
                        proj.element.className = 'projectile';
                        proj.element.style.left = proj.x + 'px';
                        proj.element.style.top = proj.y + 'px';
                        proj.element.style.background = tower.isPlayer ? '#4CAF50' : '#f44336';
                        document.getElementById('arena').appendChild(proj.element);
                        gameState.projectiles.push(proj);
                        tower.attackCooldown = 60; // Tower attack speed
                    }
                }
            });

            // Update units
            gameState.units.forEach(unit => {
                if (unit.hp <= 0) return;

                // Update status effects
                if (unit.frozen > 0) {
                    unit.frozen--;
                    if (unit.frozen === 0) {
                        unit.element.style.filter = '';
                    }
                    return; // Skip movement and attack when frozen
                }

                if (unit.rageBoost > 0) {
                    unit.rageBoost--;
                    if (unit.rageBoost === 0) {
                        unit.element.style.filter = '';
                    }
                }

                // Find target
                let target = findTarget(unit);
                
                if (target) {
                    const dx = target.x - unit.x;
                    const dy = target.y - unit.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= unit.range) {
                        // Attack
                        const attackSpeed = unit.rageBoost > 0 ? 20 : 30;
                        if (unit.attackCooldown <= 0) {
                            attack(unit, target);
                            unit.attackCooldown = attackSpeed;
                        }
                    } else {
                        // Move towards target with collision avoidance
                        const angle = Math.atan2(dy, dx);
                        const moveSpeed = unit.rageBoost > 0 ? unit.speed * 1.5 : unit.speed;
                        let newX = unit.x + Math.cos(angle) * moveSpeed;
                        let newY = unit.y + Math.sin(angle) * moveSpeed;

                        // Check collision with other units - push apart
                        let pushX = 0;
                        let pushY = 0;
                        for (let other of gameState.units) {
                            if (other !== unit && other.hp > 0) {
                                const dx2 = unit.x - other.x;
                                const dy2 = unit.y - other.y;
                                const distToOther = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                
                                if (distToOther < 40 && distToOther > 0) {
                                    // Push away from each other
                                    const pushForce = (40 - distToOther) / distToOther;
                                    pushX += dx2 * pushForce * 0.5;
                                    pushY += dy2 * pushForce * 0.5;
                                }
                            }
                        }

                        // Apply movement with separation
                        unit.x = newX + pushX;
                        unit.y = newY + pushY;
                    }
                }

                unit.attackCooldown = Math.max(0, unit.attackCooldown - 1);
                unit.element.style.left = unit.x + 'px';
                unit.element.style.top = unit.y + 'px';
                
                // Dynamic z-index based on Y position for proper layering
                unit.element.style.zIndex = Math.floor(unit.y);
            });

            // Update projectiles
            gameState.projectiles.forEach(proj => {
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5 || proj.target.hp <= 0) {
                    if (proj.target.hp > 0) {
                        dealDamage(proj.target, proj.damage, proj.x, proj.y);
                    }
                    proj.element.remove();
                    proj.dead = true;
                } else {
                    const angle = Math.atan2(dy, dx);
                    proj.x += Math.cos(angle) * 8;
                    proj.y += Math.sin(angle) * 8;
                    proj.element.style.left = proj.x + 'px';
                    proj.element.style.top = proj.y + 'px';
                }
            });

            // Clean up dead entities
            gameState.units = gameState.units.filter(u => {
                if (u.hp <= 0) {
                    u.element.remove();
                    return false;
                }
                return true;
            });

            gameState.projectiles = gameState.projectiles.filter(p => !p.dead);

            requestAnimationFrame(gameLoop);
        }

        function findTarget(unit) {
            let closest = null;
            let minDist = Infinity;

            // Check towers
            gameState.towers.forEach(tower => {
                if (tower.isPlayer !== unit.isPlayer && tower.hp > 0) {
                    const dist = Math.sqrt((tower.x - unit.x) ** 2 + (tower.y - unit.y) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = tower;
                    }
                }
            });

            // Check units
            gameState.units.forEach(other => {
                if (other.isPlayer !== unit.isPlayer && other.hp > 0) {
                    const dist = Math.sqrt((other.x - unit.x) ** 2 + (other.y - unit.y) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = other;
                    }
                }
            });

            return closest;
        }

        function attack(unit, target) {
            if (unit.range > 50) {
                // Ranged attack - create projectile
                const proj = {
                    x: unit.x,
                    y: unit.y,
                    targetX: target.x || target.x + 30,
                    targetY: target.y || target.y + 40,
                    damage: unit.damage,
                    target: target,
                    element: document.createElement('div')
                };
                proj.element.className = 'projectile';
                proj.element.style.left = proj.x + 'px';
                proj.element.style.top = proj.y + 'px';
                document.getElementById('arena').appendChild(proj.element);
                gameState.projectiles.push(proj);
            } else {
                // Melee attack
                dealDamage(target, unit.damage, target.x || target.x + 30, target.y || target.y + 40);
            }
        }

        function dealDamage(target, damage, x, y) {
            target.hp -= damage;
            
            // Show damage text
            const damageText = document.createElement('div');
            damageText.className = 'damage-text';
            damageText.textContent = '-' + damage;
            damageText.style.left = x + 'px';
            damageText.style.top = y + 'px';
            document.getElementById('arena').appendChild(damageText);
            setTimeout(() => damageText.remove(), 1000);

            if (target.element && target.element.querySelector) {
                const hpEl = target.element.querySelector('.tower-hp');
                if (hpEl) {
                    hpEl.textContent = Math.max(0, target.hp);
                }
            }

            if (target.hp <= 0 && target.isKing !== undefined) {
                // Tower destroyed
                if (target.isKing) {
                    if (target.isPlayer) {
                        gameState.enemyCrowns = 3;
                    } else {
                        gameState.playerCrowns = 3;
                    }
                    endGame();
                } else {
                    if (target.isPlayer) {
                        gameState.enemyCrowns++;
                    } else {
                        gameState.playerCrowns++;
                    }
                    updateCrowns();
                }
                target.element.style.opacity = '0.3';
            }
        }

        function updateCrowns() {
            document.getElementById('playerCrowns').textContent = gameState.playerCrowns;
            document.getElementById('enemyCrowns').textContent = gameState.enemyCrowns;
        }

        function endGame() {
            gameState.gameRunning = false;
            const gameOver = document.getElementById('gameOver');
            const text = document.getElementById('gameOverText');
            const stats = document.getElementById('gameOverStats');
            
            if (gameState.playerCrowns > gameState.enemyCrowns) {
                text.textContent = 'VICTORY!';
                gameOver.className = 'game-over victory';
            } else if (gameState.playerCrowns < gameState.enemyCrowns) {
                text.textContent = 'DEFEAT!';
                gameOver.className = 'game-over defeat';
            } else {
                text.textContent = 'DRAW!';
                gameOver.className = 'game-over';
            }
            
            stats.textContent = `Final Score: ${gameState.playerCrowns} - ${gameState.enemyCrowns}`;
            gameOver.style.display = 'block';
        }

        updateElixir();
    </script>
</body>
</html>
