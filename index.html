<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .menu {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            text-align: center;
            max-width: 400px;
        }

        .menu h1 {
            color: #ffd700;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        .menu button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(245, 87, 108, 0.5);
        }

        #gameContainer {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #arena {
            position: relative;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #4a90e2 0%, #8b4513 50%, #e74c3c 100%);
            overflow: hidden;
        }

        .bridge {
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-50%);
        }

        .tower {
            position: absolute;
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #8b4513, #a0522d);
            border-radius: 10px 10px 0 0;
            border: 3px solid #654321;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .tower.player {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            border-color: #0D47A1;
        }

        .tower::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 20px solid #654321;
        }

        .tower.player::before {
            border-bottom-color: #0D47A1;
        }

        .tower-hp {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
        }

        .unit {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 12px;
            transition: all 0.1s;
            cursor: pointer;
            pointer-events: none; /* Units shouldn't block clicks to the arena */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 50;
        }

        .unit-hp {
            position: absolute;
            top: -10px;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #e74c3c;
            border-radius: 2px;
            overflow: hidden;
        }

        .unit-hp-bar {
            height: 100%;
            background-color: #2ecc71;
            transition: width 0.1s linear;
        }

        .unit.player {
            background-color: #2980b9;
        }

        .unit.enemy {
            background-color: #c0392b;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            z-index: 100;
        }

        #elixirBar {
            background: #000;
            border: 3px solid #ffd700;
            border-radius: 20px;
            width: 250px;
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 5px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        #elixirAmount {
            height: 80%;
            background: linear-gradient(to right, #9b59b6, #8e44ad);
            border-radius: 15px;
            transition: width 0.5s ease-out;
        }

        #elixirText {
            position: absolute;
            width: 250px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 3px #000;
        }

        #stats {
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 5px 15px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
        }

        .crowns {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .crown {
            font-size: 24px;
        }

        #cardDeck {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .card {
            width: 80px;
            height: 100px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border: 4px solid #f39c12;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s, box-shadow 0.1s;
            user-select: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .card:hover:not(.disabled) {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(243, 156, 18, 0.5);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-cost {
            position: absolute;
            top: -10px;
            left: -10px;
            background: #3498db;
            color: white;
            border: 3px solid #2980b9;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            z-index: 1;
        }

        .card-icon {
            font-size: 30px;
        }

        /* --- START OF MODIFIED CSS --- */
        .card-name {
            font-size: 12px;
            font-weight: bold;
            color: white;
            /* Update to center text and emoji horizontally */
            display: flex; 
            align-items: center;
            justify-content: center;
            padding-top: 5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* New style for the spell emoji */
        .spell-emoji {
            font-size: 14px; /* Adjust size of emoji */
            margin-right: 3px;
        }
        /* --- END OF MODIFIED CSS --- */

        .card-timer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            display: none;
        }

        .spell-effect {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 80;
        }

        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 200;
        }

        #gameOver.victory {
            background: rgba(46, 204, 113, 0.9);
        }

        #gameOver.defeat {
            background: rgba(231, 76, 60, 0.9);
        }

        #gameOverText {
            font-size: 80px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
        }

        #gameOverStats {
            font-size: 30px;
            margin-bottom: 40px;
        }

        #restartButton {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            padding: 15px 40px;
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #restartButton:hover {
            background: linear-gradient(135deg, #2980b9 0%, #3498db 100%);
        }
    </style>
</head>
<body>
    <div class="menu" id="menu">
        <h1>‚öîÔ∏è CLASH ROYALE</h1>
        <button onclick="startGame('easy')">Easy Mode</button>
        <button onclick="startGame('medium')">Medium Mode</button>
        <button onclick="startGame('hard')">Hard Mode</button>
    </div>

    <div id="gameContainer">
        <div id="arena">
            <div class="bridge"></div>
        </div>

        <div id="ui">
            <div id="elixirBar">
                <div id="elixirAmount"></div>
                <div id="elixirText">0/10</div>
            </div>
            <div id="stats">
                <div class="crowns player">
                    <span class="crown" id="playerCrowns">0</span>
                    <span class="crown">üëë</span>
                </div>
                <div class="crowns enemy">
                    <span class="crown">üëë</span>
                    <span class="crown" id="enemyCrowns">0</span>
                </div>
            </div>
        </div>

        <div id="cardDeck">
            </div>

        <div id="gameOver">
            <div id="gameOverText">VICTORY!</div>
            <div id="gameOverStats">Final Score: 3 - 1</div>
            <button id="restartButton" onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        const arena = document.getElementById('arena');
        const gameContainer = document.getElementById('gameContainer');
        const menu = document.getElementById('menu');
        const elixirAmountEl = document.getElementById('elixirAmount');
        const elixirTextEl = document.getElementById('elixirText');
        const cardDeckEl = document.getElementById('cardDeck');

        // Game State and Constants
        const CARD_LIST = [
            {name: 'Knight', cost: 3, hp: 1000, damage: 150, speed: 2, range: 1, icon: 'üõ°Ô∏è', type: 'troop'},
            {name: 'Archers', cost: 3, hp: 200, damage: 50, speed: 2, range: 500, icon: 'üèπ', type: 'troop'},
            {name: 'Giant', cost: 5, hp: 2500, damage: 100, speed: 1, range: 1, icon: 'ü™®', type: 'troop'},
            {name: 'Prince', cost: 5, hp: 1200, damage: 200, speed: 3, range: 1, icon: 'ü§¥', type: 'troop'},
            {name: 'Witch', cost: 5, hp: 500, damage: 60, speed: 2, range: 150, icon: 'üßô‚Äç‚ôÄÔ∏è', type: 'troop'},
            {name: 'Bomber', cost: 3, hp: 300, damage: 170, speed: 2, range: 100, icon: 'üí£', type: 'troop'},
            {name: 'Fireball', cost: 4, damage: 500, radius: 150, icon: 'üî•', type: 'spell'},
            {name: 'Arrows', cost: 3, damage: 200, radius: 300, icon: 'üéØ', type: 'spell'},
            {name: 'Rage', cost: 2, duration: 8, radius: 200, icon: 'üò°', type: 'spell'},
            {name: 'Heal', cost: 3, duration: 3, radius: 200, icon: 'üíö', type: 'spell'}
        ];

        let gameState = {
            gameRunning: false,
            elixir: 5,
            maxElixir: 10,
            elixirRate: 1.4, // seconds per elixir point
            elixirInterval: null,
            deck: [],
            hand: [],
            discard: [],
            units: [],
            towers: [],
            effects: [],
            playerCrowns: 0,
            enemyCrowns: 0,
            gameDuration: 180, // 3 minutes
            difficulty: 'medium',
            lastCardPlayed: 0
        };

        const CARD_CYCLE_TIME = 1000; // Time in ms before a card can cycle back in
        const AI_THINK_INTERVAL = 1000;

        function getRandomCards(count) {
            const shuffled = CARD_LIST.slice().sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function createDeckAndHand() {
            // Player deck and hand
            gameState.deck = getRandomCards(8);
            gameState.hand = gameState.deck.splice(0, 4);
            gameState.discard = [];
            
            // Enemy deck (simplified for this version)
            gameState.enemyDeck = getRandomCards(8);
        }

        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            menu.style.display = 'none';
            gameContainer.style.display = 'block';
            gameState.gameRunning = true;
            
            createDeckAndHand();
            createTowers();
            updateElixir();
            updateCrowns();
            renderHand();
            
            gameState.elixirInterval = setInterval(startElixirGeneration, 1000); // Start the main elixir tick
            setInterval(gameLoop, 100); // Main game loop (10 times per second)
            setInterval(aiThink, AI_THINK_INTERVAL); // AI logic
            
            setTimeout(() => {
                // Double elixir at 1:00 remaining
                gameState.elixirRate = 0.7; 
            }, (gameState.gameDuration - 60) * 1000);

            setTimeout(() => {
                // End game after initial duration
                endGame();
            }, gameState.gameDuration * 1000);
        }

        function updateElixir() {
            const percentage = (gameState.elixir / gameState.maxElixir) * 100;
            elixirAmountEl.style.width = `${percentage}%`;
            elixirTextEl.textContent = `${Math.floor(gameState.elixir)}/${gameState.maxElixir}`;
            
            // Re-render hand to enable/disable cards
            renderHand();
        }

        function startElixirGeneration() {
            if (gameState.gameRunning && gameState.elixir < gameState.maxElixir) {
                // Logic to increment elixir over time
                gameState.elixir = Math.min(gameState.maxElixir, gameState.elixir + (1 / gameState.elixirRate));
                updateElixir();
            }
        }

        function createTower(x, y, hp, isPlayer, isKing) {
            const tower = {
                x: x,
                y: y,
                hp: hp,
                maxHp: hp,
                damage: 50,
                range: 400,
                attackCooldown: 0,
                isPlayer: isPlayer,
                isKing: isKing,
                element: document.createElement('div')
            };

            tower.element.className = `tower ${isPlayer ? 'player' : 'enemy'}`;
            tower.element.style.left = `${x}px`;
            tower.element.style.top = `${y}px`;
            
            // HP Bar
            const hpEl = document.createElement('div');
            hpEl.className = 'tower-hp';
            hpEl.textContent = `${tower.hp}`;
            tower.hpEl = hpEl;
            tower.element.appendChild(hpEl);

            arena.appendChild(tower.element);
            gameState.towers.push(tower);
        }

        function createTowers() {
            gameState.towers = [];
            const arenaWidth = arena.offsetWidth;
            const arenaHeight = arena.offsetHeight;

            // Player towers (bottom)
            createTower(arenaWidth / 2 - 30, arenaHeight - 140, 3000, true, true); // King Tower
            createTower(100, arenaHeight - 200, 1500, true, false); // Left Princess Tower
            createTower(arenaWidth - 160, arenaHeight - 200, 1500, true, false); // Right Princess Tower

            // Enemy towers (top)
            createTower(arenaWidth / 2 - 30, 20, 3000, false, true); // King Tower
            createTower(100, 100, 1500, false, false); // Left Princess Tower
            createTower(arenaWidth - 160, 100, 1500, false, false); // Right Princess Tower
        }

        // --- START OF MODIFIED FUNCTION ---
        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.dataset.name = card.name;
            
            // Add the Magic Wand emoji (ü™Ñ) next to spell card names
            const spellEmoji = card.type === 'spell' ? '<span class="spell-emoji">ü™Ñ</span>' : '';

            cardEl.innerHTML = `
                <div class="card-cost">${card.cost}</div>
                <div class="card-icon">${card.icon}</div>
                <div class="card-name">${spellEmoji}${card.name}</div>
                <div class="card-timer"></div>
            `;
            // --- END OF MODIFIED FUNCTION ---

            cardEl.onclick = (event) => {
                if (cardEl.classList.contains('disabled')) return;
                
                // Set the selected card for deployment
                gameState.selectedCard = card;
            };

            return cardEl;
        }

        function renderHand() {
            cardDeckEl.innerHTML = '';
            
            gameState.hand.forEach((card, index) => {
                const cardEl = createCardElement(card);
                if (card.cost > gameState.elixir || card.cooldown > 0) {
                    cardEl.classList.add('disabled');
                }
                
                const timerEl = cardEl.querySelector('.card-timer');
                if (card.cooldown > 0) {
                    timerEl.style.display = 'flex';
                    timerEl.textContent = Math.ceil(card.cooldown / 1000);
                } else {
                    timerEl.style.display = 'none';
                }
                
                cardEl.dataset.index = index;
                cardDeckEl.appendChild(cardEl);
            });
        }

        function cycleCard(playedCardIndex) {
            const card = gameState.hand[playedCardIndex];
            
            // 1. Move card to discard pile and start cooldown
            card.cooldown = CARD_CYCLE_TIME;
            gameState.discard.push(card);
            gameState.hand.splice(playedCardIndex, 1);
            
            // 2. Draw new card from deck
            let newCard;
            if (gameState.deck.length > 0) {
                newCard = gameState.deck.shift();
            } else if (gameState.discard.length > 0) {
                // If deck is empty, shuffle discard back into deck (simplified: just take one from discard)
                const discardIndex = Math.floor(Math.random() * gameState.discard.length);
                newCard = gameState.discard.splice(discardIndex, 1)[0];
            }
            
            if (newCard) {
                gameState.hand.push(newCard);
            }
            
            renderHand();
        }

        function updateCooldowns(deltaTime) {
            // Update cooldowns on all cards in the discard pile
            for (let i = gameState.discard.length - 1; i >= 0; i--) {
                const card = gameState.discard[i];
                card.cooldown = Math.max(0, card.cooldown - deltaTime);
                
                if (card.cooldown === 0) {
                    // Move card from discard back to deck (ready for next draw)
                    const readyCard = gameState.discard.splice(i, 1)[0];
                    gameState.deck.push(readyCard);
                }
            }
            
            // Update timers on cards in hand (only for visual effect, actual draw is from deck)
            gameState.hand.forEach(card => {
                // The main card cycling logic handles where the card is when ready, 
                // this is just for the visual timer on the hand if a card is put back on a short cooldown.
                // Re-running renderHand() handles visual timer:
                // renderHand();
            });
        }

        function handleCardPlacement(event) {
            if (!gameState.selectedCard) return;

            const card = gameState.selectedCard;
            const rect = arena.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Find the card in the hand to get its index
            const cardIndex = gameState.hand.findIndex(c => c.name === card.name);
            if (cardIndex === -1) {
                gameState.selectedCard = null;
                return;
            }

            if (card.cost <= gameState.elixir) {
                gameState.elixir -= card.cost;
                updateElixir();

                if (card.type === 'troop') {
                    spawnUnit(x, y, card, true);
                } else if (card.type === 'spell') {
                    castSpell(x, y, card, true);
                }

                cycleCard(cardIndex);
            }
            
            gameState.selectedCard = null;
        }

        // Arena click listener for card placement
        arena.addEventListener('click', (event) => {
            if (gameState.selectedCard) {
                handleCardPlacement(event);
            }
        });

        // Highlight selected card on hover
        arena.addEventListener('mousemove', (event) => {
            if (!gameState.selectedCard) {
                arena.style.cursor = 'default';
                return;
            }

            const card = gameState.selectedCard;
            if (card.type === 'troop') {
                arena.style.cursor = 'crosshair';
            } else if (card.type === 'spell') {
                // Draw a circle for AoE spells
                // This is a simplified visual. For a full game, you'd add a temporary div.
                arena.style.cursor = 'copy'; 
            }
        });

        // Helper to find a nearby empty spot for spawning
        function findFreeSpot(x, y, size) {
            const occupied = gameState.units.filter(u => 
                u.x > x - 50 && u.x < x + 50 && 
                u.y > y - 50 && u.y < y + 50 && 
                u.hp > 0
            );

            if (occupied.length === 0) {
                return {x, y};
            }
            
            // Simple logic: just shift slightly if occupied
            return {
                x: x + (Math.random() > 0.5 ? size : -size) * 0.1,
                y: y + (Math.random() > 0.5 ? size : -size) * 0.1
            };
        }

        function spawnUnit(x, y, card, isPlayer) {
            // Check for collision and find free spot
            const finalPos = findFreeSpot(x, y, 40);

            const unit = {
                x: finalPos.x,
                y: finalPos.y,
                hp: card.hp,
                maxHp: card.hp,
                damage: card.damage,
                speed: card.speed,
                range: card.range,
                isPlayer,
                name: card.name,
                icon: card.icon,
                attackCooldown: 0,
                target: null,
                element: document.createElement('div')
            };

            unit.element.className = `unit ${isPlayer ? 'player' : 'enemy'}`;
            unit.element.style.left = `${unit.x - 20}px`;
            unit.element.style.top = `${unit.y - 20}px`;
            unit.element.textContent = unit.icon;

            // HP Bar
            const hpEl = document.createElement('div');
            hpEl.className = 'unit-hp';
            const hpBarEl = document.createElement('div');
            hpBarEl.className = 'unit-hp-bar';
            hpBarEl.style.width = '100%';
            hpEl.appendChild(hpBarEl);
            unit.hpBarEl = hpBarEl;
            unit.element.appendChild(hpEl);

            arena.appendChild(unit.element);
            gameState.units.push(unit);
        }

        function findTarget(unit) {
            const enemies = [...gameState.units.filter(u => u.isPlayer !== unit.isPlayer && u.hp > 0), 
                             ...gameState.towers.filter(t => t.isPlayer !== unit.isPlayer && t.hp > 0)];

            let nearestTarget = null;
            let minDist = Infinity;
            
            // Troop Target Priority: Troops > Towers
            for (const target of enemies) {
                // Ignore King Tower until Princess Tower is down
                if (target.isKing && !gameState.towers.some(t => t.isPlayer !== unit.isPlayer && !t.isKing && t.hp > 0)) {
                    // Proceed to King Tower only if all other towers are destroyed
                } else if (target.isKing && gameState.towers.some(t => t.isPlayer !== unit.isPlayer && !t.isKing && t.hp > 0)) {
                    continue; // Skip King Tower if a Princess Tower is still up
                }

                const dx = (target.x || target.x + 30) - unit.x;
                const dy = (target.y || target.y + 40) - unit.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= unit.range && dist < minDist) {
                    minDist = dist;
                    nearestTarget = target;
                }
            }
            
            // If no immediate target in range, find the nearest enemy (units first)
            if (!nearestTarget) {
                for (const target of enemies) {
                     // Check the king tower logic again for initial movement
                    if (target.isKing && gameState.towers.some(t => t.isPlayer !== unit.isPlayer && !t.isKing && t.hp > 0)) {
                        continue;
                    }

                    const dx = (target.x || target.x + 30) - unit.x;
                    const dy = (target.y || target.y + 40) - unit.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearestTarget = target;
                    }
                }
            }

            return nearestTarget;
        }

        function moveUnit(unit, deltaTime) {
            if (unit.target) {
                // If target is in range, stop and attack
                const targetX = unit.target.x || unit.target.x + 30;
                const targetY = unit.target.y || unit.target.y + 40;

                const dx = targetX - unit.x;
                const dy = targetY - unit.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= unit.range) {
                    // Stop movement
                    return; 
                }

                // Move towards target
                const angle = Math.atan2(dy, dx);
                const moveDist = unit.speed * deltaTime * 0.1; // Scale speed by deltaTime
                unit.x += Math.cos(angle) * moveDist;
                unit.y += Math.sin(angle) * moveDist;

            } else {
                // No target, move towards the nearest enemy Princess Tower
                const enemyTowers = gameState.towers.filter(t => t.isPlayer !== unit.isPlayer && !t.isKing && t.hp > 0);
                
                let targetTower = null;
                let minDist = Infinity;

                for (const tower of enemyTowers) {
                    const dx = tower.x + 30 - unit.x;
                    const dy = tower.y + 40 - unit.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        targetTower = tower;
                    }
                }
                
                // If no princess towers, target the king tower
                if (!targetTower) {
                    targetTower = gameState.towers.find(t => t.isPlayer !== unit.isPlayer && t.isKing);
                }

                if (targetTower) {
                    const dx = targetTower.x + 30 - unit.x;
                    const dy = targetTower.y + 40 - unit.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > unit.range) {
                        const angle = Math.atan2(dy, dx);
                        const moveDist = unit.speed * deltaTime * 0.1;
                        unit.x += Math.cos(angle) * moveDist;
                        unit.y += Math.sin(angle) * moveDist;
                    }
                }
            }

            // Simple collision detection/separation (to prevent stacking)
            let pushX = 0;
            let pushY = 0;
            gameState.units.forEach(other => {
                if (unit !== other) {
                    const dx2 = unit.x - other.x;
                    const dy2 = unit.y - other.y;
                    const distToOther = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    
                    if (distToOther < 40 && distToOther > 0) {
                        // Push away from each other
                        const pushForce = (40 - distToOther) / distToOther;
                        pushX += dx2 * pushForce * 0.5;
                        pushY += dy2 * pushForce * 0.5;
                    }
                }
            });
            
            // Apply movement with separation
            unit.x += pushX * 0.1;
            unit.y += pushY * 0.1;
            
            // Keep unit within arena bounds (simplified)
            const arenaWidth = arena.offsetWidth;
            const arenaHeight = arena.offsetHeight;
            unit.x = Math.max(20, Math.min(unit.x, arenaWidth - 20));
            unit.y = Math.max(20, Math.min(unit.y, arenaHeight - 20));

            // Update visual position
            unit.element.style.left = `${unit.x - 20}px`;
            unit.element.style.top = `${unit.y - 20}px`;
        }

        function attackTarget(attacker, target) {
            const targetX = target.x || target.x + 30;
            const targetY = target.y || target.y + 40;
            
            const dx = targetX - attacker.x;
            const dy = targetY - attacker.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist <= attacker.range) {
                attacker.attackCooldown = 10; // 1 second cooldown (10 frames)
                dealDamage(target, attacker.damage);
            }
        }

        function towerLogic(tower) {
            if (tower.hp <= 0) return;
            
            tower.attackCooldown = Math.max(0, tower.attackCooldown - 1);
            
            if (tower.attackCooldown === 0) {
                // Find nearest enemy unit
                let nearestEnemy = null;
                let minDist = tower.range;
                
                gameState.units.forEach(unit => {
                    if (unit.isPlayer !== tower.isPlayer && unit.hp > 0) {
                        const dx = unit.x - (tower.x + 30);
                        const dy = unit.y - (tower.y + 40);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist <= tower.range && dist < minDist) {
                            minDist = dist;
                            nearestEnemy = unit;
                        }
                    }
                });
                
                if (nearestEnemy) {
                    tower.attackCooldown = 10; // Tower attack speed (1 attack per second)
                    dealDamage(nearestEnemy, tower.damage);
                }
            }
        }

        function castSpell(x, y, card, isPlayer) {
            const effect = {
                x: x,
                y: y,
                radius: card.radius,
                damage: card.damage,
                duration: card.duration * 10 || 1, // duration in frames (10 frames = 1 second)
                card: card,
                isPlayer: isPlayer,
                element: document.createElement('div')
            };

            effect.element.className = 'spell-effect';
            effect.element.style.width = `${effect.radius * 2}px`;
            effect.element.style.height = `${effect.radius * 2}px`;
            effect.element.style.left = `${x - effect.radius}px`;
            effect.element.style.top = `${y - effect.radius}px`;
            effect.element.style.opacity = '1';
            
            if (card.name === 'Fireball') {
                effect.element.style.background = 'radial-gradient(circle, rgba(255,100,0,0.8), rgba(255,0,0,0.5))';
                applySpellEffect(effect);
                effect.duration = 1; // Instant spell
            } else if (card.name === 'Arrows') {
                effect.element.style.background = 'radial-gradient(circle, rgba(200,200,200,0.8), rgba(100,100,100,0.5))';
                applySpellEffect(effect);
                effect.duration = 1; // Instant spell
            } else if (card.name === 'Rage') {
                effect.element.style.background = 'radial-gradient(circle, rgba(255,0,150,0.6), rgba(200,0,100,0.3))';
                // Rage is a persistent effect
                effect.isPersistent = true;
            } else if (card.name === 'Heal') {
                effect.element.style.background = 'radial-gradient(circle, rgba(0,255,100,0.6), rgba(100,255,100,0.3))';
                applySpellEffect(effect);
                effect.duration = 1; // Instant spell
            }
            
            arena.appendChild(effect.element);
            gameState.effects.push(effect);
        }

        function applySpellEffect(effect) {
            // Find all units and towers in the radius
            const targets = [
                ...gameState.units.filter(u => u.hp > 0),
                ...gameState.towers.filter(t => t.hp > 0)
            ];

            targets.forEach(target => {
                const targetX = target.x || target.x + 30;
                const targetY = target.y || target.y + 40;

                const dx = targetX - effect.x;
                const dy = targetY - effect.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= effect.radius) {
                    if (effect.card.name === 'Fireball' || effect.card.name === 'Arrows') {
                        // Damage enemy troops/towers
                        if (target.isPlayer !== effect.isPlayer) {
                            dealDamage(target, effect.damage);
                        }
                    } else if (effect.card.name === 'Heal') {
                        // Heal friendly troops
                        if (target.isPlayer === effect.isPlayer) {
                            dealDamage(target, -effect.damage); // Negative damage is heal
                        }
                    } else if (effect.card.name === 'Rage') {
                        // Rage effect (for units only)
                        if (target.isPlayer === effect.isPlayer && target.name) {
                            // Apply a 'rage' flag or modifier to the unit
                            target.isRaged = true;
                            target.originalSpeed = target.originalSpeed || target.speed;
                            target.originalDamage = target.originalDamage || target.damage;
                            target.speed *= 1.4;
                            target.damage *= 1.4;
                        }
                    }
                }
            });
        }

        function processSpellEffects() {
            for (let i = gameState.effects.length - 1; i >= 0; i--) {
                const effect = gameState.effects[i];
                
                effect.duration--;
                
                // Persistent effects (like Rage) need continuous application/checking
                if (effect.isPersistent) {
                    applySpellEffect(effect); // Re-apply to all units in range
                }

                if (effect.duration <= 0) {
                    // Clean up rage effect on units that were in the area
                    if (effect.card.name === 'Rage') {
                        gameState.units.forEach(unit => {
                            // Find units near the spell area
                            const dx = unit.x - effect.x;
                            const dy = unit.y - effect.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (unit.isRaged && dist <= effect.radius) {
                                // Revert stats
                                unit.speed = unit.originalSpeed;
                                unit.damage = unit.originalDamage;
                                unit.isRaged = false;
                                delete unit.originalSpeed;
                                delete unit.originalDamage;
                            }
                        });
                    }
                    
                    effect.element.style.opacity = '0';
                    setTimeout(() => effect.element.remove(), 300);
                    gameState.effects.splice(i, 1);
                }
            }
        }

        function aiThink() {
            if (!gameState.gameRunning) return;

            // Simplified AI logic based on difficulty
            const enemyElixir = gameState.elixir;
            const enemyUnits = gameState.units.filter(u => !u.isPlayer && u.hp > 0);
            const playerUnits = gameState.units.filter(u => u.isPlayer && u.hp > 0);
            const aiDeck = gameState.enemyDeck; // Use the simplified enemy deck for random card selection

            // AI Deployment Decision
            if (enemyElixir >= 3 && Math.random() < 0.5) { // 50% chance to try playing a card every second
                
                let playableCards = CARD_LIST.filter(c => c.cost <= enemyElixir);
                
                // Add difficulty modifier
                if (gameState.difficulty === 'easy') {
                    playableCards = playableCards.filter(c => c.cost <= 4);
                } else if (gameState.difficulty === 'hard') {
                    // Prioritize high-cost cards if elixir is high
                    if (enemyElixir >= 7) {
                        playableCards = CARD_LIST.filter(c => c.cost >= 5);
                    }
                }
                
                if (playableCards.length > 0) {
                    const card = playableCards[Math.floor(Math.random() * playableCards.length)];
                    
                    // AI card placement logic (always on the enemy side of the bridge)
                    const arenaWidth = arena.offsetWidth;
                    const arenaHeight = arena.offsetHeight;
                    
                    let deployX, deployY;
                    
                    if (card.type === 'troop') {
                        // Deploy troops near king tower or near a bridge (randomized)
                        if (Math.random() < 0.5) {
                            // Near king tower
                            deployX = arenaWidth / 2 - 20 + (Math.random() * 80 - 40);
                            deployY = 50 + (Math.random() * 50);
                        } else {
                            // Near bridge
                            deployX = Math.random() < 0.5 ? 100 + (Math.random() * 100) : arenaWidth - 200 - (Math.random() * 100);
                            deployY = arenaHeight / 2 - 50 - (Math.random() * 50);
                        }
                        
                        spawnUnit(deployX, deployY, card, false);
                        
                    } else if (card.type === 'spell') {
                        // Cast spells on enemy troops/towers (simplified: just on player's side)
                        let targetPosition = null;
                        
                        // 1. Target player's tower if spell is offensive (Fireball, Arrows)
                        if (card.name === 'Fireball' || card.name === 'Arrows') {
                            const playerTowers = gameState.towers.filter(t => t.isPlayer && !t.isKing && t.hp > 0);
                            if (playerTowers.length > 0) {
                                const targetTower = playerTowers[Math.floor(Math.random() * playerTowers.length)];
                                targetPosition = {x: targetTower.x + 30, y: targetTower.y + 40};
                            }
                        }
                        
                        // 2. Target largest cluster of player units if offensive
                        const playerUnits = gameState.units.filter(u => u.isPlayer && u.hp > 0);
                        if (!targetPosition && playerUnits.length >= 2) {
                            const cluster = findLargestCluster(playerUnits, card.radius);
                            if (cluster.count >= 2) {
                                targetPosition = {x: cluster.x, y: cluster.y};
                            }
                        }
                        
                        // 3. Cast support spells (Rage/Heal) on its own troops (simplified)
                        if ((card.name === 'Rage' || card.name === 'Heal') && enemyUnits.length > 0) {
                            targetPosition = {x: enemyUnits[0].x, y: enemyUnits[0].y};
                        }

                        if (targetPosition) {
                            castSpell(targetPosition.x, targetPosition.y, card, false);
                        }
                    }
                    
                    gameState.elixir -= card.cost;
                    updateElixir();
                }
            }
        }

        function findLargestCluster(units, radius) {
            let maxCount = 0;
            let bestX = 0;
            let bestY = 0;
            
            for (const unit of units) {
                let currentCount = 0;
                let sumX = 0;
                let sumY = 0;
                
                for (const otherUnit of units) {
                    const dx = otherUnit.x - unit.x;
                    const dy = otherUnit.y - unit.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist <= radius) {
                        currentCount++;
                        sumX += otherUnit.x;
                        sumY += otherUnit.y;
                    }
                }

                if (currentCount > maxCount) {
                    maxCount = currentCount;
                    bestX = sumX / currentCount;
                    bestY = sumY / currentCount;
                }
            }
            
            return {count: maxCount, x: bestX, y: bestY};
        }

        // Main Game Loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameState.gameRunning) return;
            
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Update cooldowns
            updateCooldowns(deltaTime);
            renderHand(); // Update card timers

            // Update Units
            gameState.units.forEach(unit => {
                if (unit.hp <= 0) return;
                
                unit.attackCooldown = Math.max(0, unit.attackCooldown - 1);

                // 1. Find or maintain target
                if (!unit.target || unit.target.hp <= 0) {
                    unit.target = findTarget(unit);
                }

                // 2. Move
                moveUnit(unit, deltaTime);

                // 3. Attack
                if (unit.target && unit.attackCooldown === 0) {
                    attackTarget(unit, unit.target);
                }
                
                // Update HP visual
                const hpPercent = (unit.hp / unit.maxHp) * 100;
                unit.hpBarEl.style.width = `${hpPercent}%`;
            });
            
            // Update Towers
            gameState.towers.forEach(towerLogic);

            // Process Spells
            processSpellEffects();

            // Cleanup destroyed units
            for (let i = gameState.units.length - 1; i >= 0; i--) {
                const unit = gameState.units[i];
                if (unit.hp <= 0 && unit.element.parentElement) {
                    unit.element.remove();
                    gameState.units.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        function dealDamage(target, damage) {
            target.hp -= damage;
            
            // Healing logic (negative damage)
            if (damage < 0 && target.hp > target.maxHp) {
                target.hp = target.maxHp;
            }

            // Visual update for towers
            if (target.tower) {
                target.hpEl.textContent = `${Math.max(0, target.hp)}`;
            }

            if (target.hp <= 0) {
                // If it's a tower, check for game end
                if (target.element.classList.contains('tower')) {
                    if (target.isKing) {
                        // King tower destroyed, immediate game end
                        endGame(); 
                        return;
                    }
                    
                    // Princess tower destroyed, give a crown and make king tower targetable
                    if (!target.isPlayer) {
                        gameState.enemyCrowns++;
                    } else {
                        gameState.playerCrowns++;
                    }
                    updateCrowns();
                }
                target.element.style.opacity = '0.3';
            }
        }

        function updateCrowns() {
            document.getElementById('playerCrowns').textContent = gameState.playerCrowns;
            document.getElementById('enemyCrowns').textContent = gameState.enemyCrowns;
        }

        function endGame() {
            gameState.gameRunning = false;
            clearInterval(gameState.elixirInterval); // Stop elixir generation
            
            const gameOver = document.getElementById('gameOver');
            const text = document.getElementById('gameOverText');
            const stats = document.getElementById('gameOverStats');
            
            if (gameState.playerCrowns > gameState.enemyCrowns) {
                text.textContent = 'VICTORY!';
                gameOver.className = 'game-over victory';
            } else if (gameState.playerCrowns < gameState.enemyCrowns) {
                text.textContent = 'DEFEAT!';
                gameOver.className = 'game-over defeat';
            } else {
                text.textContent = 'DRAW!';
                gameOver.className = 'game-over';
            }
            
            stats.textContent = `Final Score: ${gameState.playerCrowns} - ${gameState.enemyCrowns}`;
            gameOver.style.display = 'flex';
        }

        // Initialize display
        updateElixir();
    </script>
</body>
</html>
